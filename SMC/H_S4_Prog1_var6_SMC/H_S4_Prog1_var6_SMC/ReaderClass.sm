%start RMap::Ftp
%class ReaderClass
%header   ReaderClass.h

%map RMap
%%

Default //Если получаем что-то не переопределённое (то есть, неожиданное) - падаем в ошибку
{
	Dig(c: char) Error {}
	Letter(c: char) Error {}
	Colon Error {}
	Slash Error {}
	Dot Error {}
	Unknown Error {} //Любой неизвестный символ (типа $)
	EOS Error { fFail(); } //Получив конец строки, ставим флаг ошибки (кроме "удачного" случая, который переопределён ниже)
	Reset Ftp {}
}

Ftp //Считывание "ftp"
{ //Все функции написаны в ReaderClass.h. Если обращаемся к функции в условиях (квадратные скобки), пишем .ctxt
	Letter(c: char)[ctxt.checkFL()] nil { addFS(c); } //Пока длина меньше 3, читаем символы. Если больше - то это уже не ftp.
	Colon[ctxt.checkFtp()] Sl1 {} //По двоеточию переходим дальше. Проверяем совпадение строки с "ftp".
}

Sl1
{
	Slash Sl2 {} //Получили двоеточие, читаем первый слэш
}

Sl2
{
	Slash Server {} //Второй слэш
}

Server
{
	Letter(c: char)[ctxt.checkSL()] nil { addSS(c); incTL(); } //Читаем имя сервера, пока длина позволяет. С этого момента начинаем увеличивать "общую длину строки". (Но не проверяем, пока она ТОЧНО меньше 64)
	Dig(c: char)[ctxt.checkSL()] nil { addSS(c); incTL(); } //То же самое
	Dot[ctxt.checkSLN()] DomZone { incTL(); } //По точке продолжаем. Проверяем, что полученная строка НЕ НУЛЕВАЯ. Точки считаются в общую длину, поэтому прибавляем ТЛ.
}

DomZone
{
	Letter(c: char)[ctxt.checkDL()] nil { incDZL(); incTL(); } //Теперь запоминать строку не нужно. Просто с каждым символом увеличиваем длину домена/зоны и суммарной строки. Проверяем только длину <20 - иначе точно ошибка.
	Dig(c: char)[ctxt.checkDL()] nil { incDZL(); incTL(); setDigFlag(); } //Если получили цифру - это ТОЧНО не может быть именем зоны (в задании написано). Ставим флаг.
	Dot[ctxt.checkDZLN() && ctxt.checkTL()] nil { resetDZL(); resetDigFlag(); incTL(); } //Если точка - значит, надо читать ещё один домен. Но перед началом проверяем, не превысили ли мы ОБЩУЮ длину строки (иначе можно было бы вечно вводить домены). Ну, и убеждаемся, что строка не нулевая. Флаг цифры можно снять - всё хорошо, цифры в домене быть могут.
	EOS[ctxt.checkZLF() && (!ctxt.checkDigFlag()) && ctxt.checkTLF()] OK { fSuccess(); } //Если конец - значит, была зона - проверяем, подходит ли длина, и не нулевая ли она (в одной функции ZLF). И проверяем, не было ли цифр - иначе ошибка. И проверяем суммарную длину строки. Если всё ок - ставим флажок успеха и сохраняем имя сервера.
}

OK
{
}

Error
{
}

%%