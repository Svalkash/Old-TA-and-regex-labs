%start RMap::Ftp
%class ReaderClass
%header   ReaderClass.h

%map RMap
%%

Default //Если получаем что-то не переопределённое (то есть, неожиданное) - падаем в ошибку
{
	Dig(c: char) Error {}
	Letter(c: char) Error {}
	Colon Error {}
	Slash Error {}
	Dot Error {}
	At Error {}
	Unknown Error {} //Любой неизвестный символ (типа $)
	EOS Error { fFail(); } //Получив конец строки, ставим флаг ошибки (кроме "удачного" случая, который переопределён ниже)
	Reset Ftp {}
}

Ftp //Считывание "ftp"
{ //Все функции написаны в ReaderClass.h. Если обращаемся к функции в условиях (квадратные скобки), пишем .ctxt
	Letter(c: char)[ctxt.checkFL()] nil { addFS(c); } //Пока длина меньше 3, читаем символы. Если больше - то это уже не ftp.
	Colon[ctxt.checkFtp()] Sl1 {} //По двоеточию переходим дальше. Проверяем совпадение строки с "ftp".
}

Sl1
{
	Slash Sl2 {} //Получили двоеточие, читаем первый слэш
}

Sl2
{
	Slash Username {} //Второй слэш
}

Username
{
	Letter(c: char)[ctxt.checkUL()] nil { incUL(); } //Читаем имя юзера, пока длина позволяет.
	Dig(c: char)[ctxt.checkUL()] nil { incUL(); } //То же самое
	At[ctxt.checkULN()] Server {} //По собаке переходим сразу к серверу. Проверяем, что полученная строка НЕ НУЛЕВАЯ.
	Colon[ctxt.checkULN()] Password {} //По двоеточию начинаем читать пароль. Проверяем, что полученная строка НЕ НУЛЕВАЯ.
}

Password
{
	Letter(c: char)[ctxt.checkPL()] nil { incPL(); } //Читаем пароль, пока длина позволяет.
	Dig(c: char)[ctxt.checkPL()] nil { incPL(); } //То же самое
	At[ctxt.checkPLN()] Server {} //По собаке переходим к серверу. Проверяем, что полученная строка НЕ НУЛЕВАЯ.
}

Server
{
	Letter(c: char)[ctxt.checkSL()] nil { addSS(c); } //Читаем имя сервера, пока длина позволяет. 
	Dig(c: char)[ctxt.checkSL()] nil { addSS(c); } //То же самое
	Dot[ctxt.checkSLN()] Zone {} //По точке продолжаем. Проверяем, что полученная строка НЕ НУЛЕВАЯ.
}

Zone
{
	Letter(c: char)[ctxt.checkZL()] nil { incZL(); } //Теперь запоминать строку не нужно. Просто с каждым символом увеличиваем длину зоны. Проверяем только длину <5 - иначе точно ошибка.
	Dot[ctxt.checkZLN()] nil { resetZL(); } //Если точка - значит, надо читать ещё раз. Ну, и убеждаемся, что строка не нулевая. Сбрасываем длину.
	EOS[ctxt.checkZLN()] OK { fSuccess(); } //Если конец - значит, была зона - проверяем, подходит ли длина, и не нулевая ли она (в одной функции ZLF). И проверяем, не было ли цифр - иначе ошибка. И проверяем суммарную длину строки. Если всё ок - ставим флажок успеха и сохраняем имя сервера.
}

OK
{
}

Error
{
}

%%